<!DOCTYPE html>
<html lang="en">
    <head>
        <link href="https://fonts.googleapis.com/css?family=Nunito:200" rel="stylesheet">
        <meta charset="utf-8">
        <title>New York City taxi data</title>
        <script type="text/javascript" src="./d3.js"></script>
        <style>
            body {
               width: 100%;
               display: flex;
               flex-direction: column;
               line-height: 150%;
               font-family: 'Nunito', sans-serif;
               margin: 0;
               background-image: url(http://blog.getliquidlandscape.com/wp-content/uploads/2017/01/sos.png);
               background-position: left top;
               background-size: auto;
               background-repeat: repeat;
               background-attachment: fixed;
            }
            .top-bar-container {
              display: flex;
              flex-direction: column;
              background-color: #329b83;
              color: white;
              width: 100%;
            }

            .top-bar-inner-container {
              align-self: center;
              display: flex;
              flex-direction: row-reverse;
              width: 900px;
            }

            .top-bar-link {
              text-decoration: underline;
              color: white;
              padding: 20px 0 20px 100px;
              font-size: 24px;
              font-weight: 100;
            }

            .website-container {
              display: flex;
              flex-direction: column;
              width: 900px;
              align-self: center;
              background-color: white;
              padding: 50px 30px 50px 30px;
              margin: 55px 0 55px 0;
              box-shadow: 0 0 1px rgba(0, 0, 0, 0.15);
            }

            .website-container-inner {
              display: flex;
              flex-direction: column;
              width: 100%;
              align-self: center;
              background-color: white;
              padding: 50px 30px 30px 30px;
              margin: 55px 0 0 0;
              box-shadow: 0 -5px 1px -5px rgba(0, 0, 0, 0.15);
            }

            .button_bottom {
              color: white;
                align-self: center;
              width: 600px;
              background-color: #039be5;
              box-shadow: 0 2px 5px 0 rgba(0,0,0,.26);
              padding: 8px 16px;
              margin: 20px 0 0 0;
              text-decoration: none;
            }

            .play-hour-btn {
              width: 240px;
              align-self: center;
              color: white;
              background-color: #039be5;
              padding: 7px 20px 7px 20px;
            }

            #hours_chart1, #duration_chart1, #pie1, #pie2 {
              align-self: center;
            }

            .subtitle {
              font-size: 24px;
              font-weight: 200;
              color: #666;
              line-height: 160%;
              margin-top: 14px;
              margin-bottom: 10px;
            }

            .subtitle-less-spacing {
              margin-top: -4px;
              margin-bottom: 10px;
            }

            h1, h2 {
              font-weight: bolder;
            }

            .taxi_pic {
              width: 100%;
              height: auto;
              margin-top: 15px;
            }

            .pic_text {
              font-size: 10px;
              font-style: italic;
              color: #888;
              align-self: flex-end;
              margin-bottom: -20px;
            }

            .map_container{
              display: flex;
              flex-direction: row;
              justify-content: space-around;
            }

        </style>
    </head>
    <body>

        <div class="top-bar-container">
          <div class="top-bar-inner-container">
            <a href="http://www.nyc.gov/html/tlc/html/about/trip_record_data.shtml" target="_blank" class="top-bar-link">The data</a>
            <a href="explainer" target="_blank" class="top-bar-link">Explainer page</a>
          </div>
        </div>




        <div class="website-container">

          <h1 class="assignment-header">Use data to gain more profit as a New York City taxi driver</h1>
          <p class="subtitle subtitle-less-spacing">
            New York City drivers can use data as an advantage and take data-driven decisions to maximize
            their income.
          </p>
          <p>
            Our findings on how New York City taxi drivers can use data to increase their chances to earn more money
            is shown below. Particularly, the effect on how many passengers were in each taxi ride and the duration of each taxi trip was examined
            for yellow taxi cabs the year 2017.
          </p>

          <img src="./taxis.jpg" class="taxi_pic"/>
          <span class="pic_text">
            Picture by
            <a href="https://www.publicdomainpictures.net/en/view-image.php?image=180391&picture=nyc-yellow-taxi" target="_blank">Public Domain Pictures.net</a>
          </span>

          <div class="website-container-inner">
            <h2>Where is the place to go for a taxi driver that is looking for a certain amount of passengers?</h2>
            <p>
              On the map below you can find how many taxi rides began in each taxi zone.
              The check boxes filter amount of taxi trips after how many passengers there were.
              When no checkbox is selected the total amount of all taxi trips for each zone, regardless of how many
               passengers there were, is shown by default. The more dark green the zone is, the more taxi rides began in that particular zone.
              When hovering over each zone you can find the name of the zone and the number of taxi rides that began
              in that zone with the chosen passengers amount.
              <br/>
              <br/>
              <br/>
            </p>



            <div class="map_container">
              <div id="geoMap">
                <h3>Passenger amount per ride <br/> in each zone</h3>
              </div>

              <div id="geoMap_checkbox">
                <br  />
                <br  />
                <br  />
                <br  />
                <br  />
                <br  />

                <h4>Choose how many passengers</h4>
                <ul>
                  <li> <input type="checkbox" id="myCheck1" onclick="updateChartBar()">
                       <span class="chart-option"> 1 </span> </li>
                  <li> <input type="checkbox" id="myCheck2" onclick="updateChartBar()">
                       <span class="chart-option"> 2 </span> </li>
                  <li> <input type="checkbox" id="myCheck3" onclick="updateChartBar()">
                       <span class="chart-option"> 3 </span> </li>
                  <li> <input type="checkbox" id="myCheck4" onclick="updateChartBar()">
                       <span class="chart-option"> 4 </span> </li>
                  <li> <input type="checkbox" id="myCheck5" onclick="updateChartBar()">
                       <span class="chart-option"> 5 </span> </li>
                  <li> <input type="checkbox" id="myCheck6" onclick="updateChartBar()" >
                       <span class="chart-option"> 6 </span> </li>
                </ul>
              </div>


            </div>

            <p>
              <br  />
              <br  />
              <br  />
              The map shows that if a taxi driver wants to get as many taxi hails as possible, he should stay in the Manhattan or
              at LaGuardia airport or JFK airport. If a driver wants to aviod driving 3, 4, 5 or 6 passengers he should stay in Staten Island.
            </p>
            <p>
              The following barchart displays the total amount of taxi rides categorised by how many passengers there were.
              For the year 2017, there were in total around 100 million yellow taxi rides.
              <br  />
              <br  />
            </p>

            <div id="passenger_bar"></div>

            <p>
              <br  />
              <br  />
              According to the NYC Taxi & Limousine Commission, the maximum amount of passengers allowed by law
              in a traditional cab is four. In a five passenger cab, that looks like a minivan, five passengers are allowed.
              However, in addition to the passenger limit, a child under the age of 7 is allowed to sit on a passenger lab.
              When examining the bar chart it is clear that in 2017 it was most likely that a taxi driver had one passenger in the car.<br  />
              It is interesting how many taxi rides had 5 and 6 passengers, compared to 3 and 4, telling us that there is really a need for
              the bigger caps. When there where 6 passengers in a ride we assume that one passenger was a young child or everyone just squeezed
              comfortably into the cab.
            </p>

            <br  />
            <br  />
            <br  />
            <br  />

            <p>
              Furthermore, it is interesting to examine if people pay more tip if there are more passengers in the cab.<br  />
              Below, there are two doughnut charts showing how big portion the tip was of the total taxi trip cost.
            </p>

              <br />
              <br />
              <h4>
                Rate between fare amount and trip amount for trips with 1 passenger
              </h4>
              <div id="pie1"></div>

              <br />

              <h4>
                Rate between fare amount and trip amount for trips with 2 or more passengers
              </h4>
              <div id="pie2"></div>

            <br  />
            <p>
              <br />
              The two doughnut charts show that there is no significant difference by how much tip the driver gets depending on the amount of passengers.
              In fact, there is slightly more likelihood to get more tip when there is only 1 passenger.
            </p>
            <p>
              In conclusion, it does not matter that much if a taxi driver should target to get certain amount of passengers as the behaviour seems
              to be very alike not depending on the passenger count. Taxi drivers should stay in Manhattan or at the two airports, LaGuardia and JFK,
              to minimize the liklihood of not getting any customers.
              TODOODODOD!!!!!!
            </p>
            <br  />
            <br  />
            <br  />
            <br  />


            <div class="website-container-inner">
              <h2>When during the day is the best time to drive?</h2>
              <p class="subtitle subtitle-less-spacing">
                How can taxi drivers use data to figure out at what time of the day they will make the most money?
              </p>
              <p>
                Lets start looking at how many trips are there for each hour of the day:
              </p>
              <div id="hours_chart2"></div>
              <p>
                From this graph, it is possible to see that there is more demand for New York
                taxis in the afternoon and in the evening but less demand during the morning and the nights.
                Around 4 and 5 AM the demand is at minimum.
                So for taxi drivers driving at the hours with high demand, they decrease their probability to stay idle
                for a long time without passengers.
              </p>
              <p>
                But it is not enough to just look at when the demand is the most for taxis so taxi drivers can maximize their
                income. It also matters of how long each taxi trip is, the longer the trip duration is, the more it costs, leading to
                 the more money for the driver.
              </p>

              <br  />
              <br  />
              <br  />
              <p class="subtitle">
                Looking at trip duration for different hours of the day
              </p>

              <p>
                By looking at how long the trips are in terms of time, or duration, it is possible to examine
                how long the trips are on different hours of the day.<br  />
                <br  />
                Below there are two graphs that visualise:
                <ul>
                  <li>An interactive, brushable, bar chart representing number of taxi trips of each hour</li>
                  <li>Bar chart representing number of taxi trips of different trip length (in minutes) in total of all the hours selected with the hour brush in the first bar chart</li>
                </ul>
                With the hour brush in the first bar chart, you can play around to see how
                the trip duration for taxi trips changes for different hours of the day, just highlight (brush)
                specific area in the first bar chart. To see the changes more easily, you can use
                the "Animate brush" button, below the first bar chart, to see the changes automatically.
              </p>
              <div id="hours_chart1"></div>
              <button onclick="onHoursPlay()" class="play-hour-btn">Animate brush!</button>
              <br  />
              <div id="duration_chart1"></div>
              <p>
                In the above graph, the yellow bar shows where the median trip is. When the trip duration is examined for different hours (try the "Animate brush" button)
                some useful information can be read from the visualisation. It seems that trips
                in the afternoon and in the evening are of longer duration compared to trips
                during the night or before noon. This means those taxi drivers who want to get more
                money from each trip should rather work in the afternoon or in the evening as longer trips cost more for the customer.<br />
                From this can be seen that there is both higher demands and longer trips in the afternoon and in the evening.
              </p>

            </div>

            <div class="website-container-inner">
              <h2>Conclusion</h2>
              <p>
                New York City taxi drivers can try to maximize their income by taking data-driven decisions.
                From the visualisation above, drivers can understand where and when they should drive to increase
                their chances of earning more money.
              </p>
            </div>


            <a href="explainer" class="button_bottom" target="_blank">
              OPEN EXPLAINER ANALYSIS PAGE
            </a>

            <a href="http://www.nyc.gov/html/tlc/html/about/trip_record_data.shtml" class="button_bottom" target="_blank">
              DATA USED IN THE PROJECT
            </a>

            <br />
            <h2>Github link</h2>
            <p>
              Link to the Github repo for this project: <a href="https://github.com/thorhildurj/socialdata2018" target="blank">https://github.com/thorhildurj/socialdata2018</a>
            </p>
            <br />

            <img src="./taxis2.jpg" class="taxi_pic"/>
            <span class="pic_text">
              Picture by
              <a href="https://commons.wikimedia.org/wiki/File:Yellow_cabs_(4855499362).jpg" target="_blank">Wikimedia Commons</a>
            </span>

          </p>

        </div>


        <script type="text/javascript">


        /**************************************************/
        /************* COMMON VARIABLES STARTS *************/
        var width = 812;
        var height = 350;
        var padding = 40;

        function make_y_axis(scale, svg) {
          return d3.axisLeft()
                    .scale(scale)
                    .ticks(5);
        }
        /************** COMMON VARIABLES ENDS *************/
        /**************************************************/



        //Function to make a new subset dataset for passenger count on map
        var getSubDataset = function (datasetWithAllTypes, passengerIndex) {
            var newDataset = [];

            //Fill in the dataset with 0 values for each zone
            for (var i = 0; i < 265; i++) {
                    newDataset.push({
                      'zone': i+1,
                      'num': 0   });
            }

            for (var i=0; i < datasetWithAllTypes.length; i++){
              var entry = datasetWithAllTypes[i];
              var zone = parseFloat(entry.PULocationID);
              var passengerValue = parseFloat(entry.passenger_count);

              for (var j=0; j < passengerIndex.length; j++){
                if (passengerValue == passengerIndex[j]) {
                  var zoneObject = newDataset[zone - 1];
                  zoneObject.num += parseFloat(entry.num);
                  newDataset[zone - 1] = zoneObject;
                }
              }
            }
            return newDataset;
        }

        //Function that checks what passenger count is checked in the checkboxes
        var isChecked = function (){
          var passengerIndexList = [];

          for (var i=1; i < 7; i++){
            var idCheck = "myCheck"+i
            if (document.getElementById(idCheck).checked){
              passengerIndexList.push(i)
            }
          }
          if (passengerIndexList.length == 0){
            passengerIndexList = [1,2,3,4,5,6];
          }
          return passengerIndexList;
        }

        /************** GEOMAP STARTS *************/
        /******************************************/
        //Width and height
        var wMap = 550;
        var hMap = 550;
        var datasetWithAllPassengers;
        var jsonData;
        var passengerIndex = [1,2,3,4,5,6];  //all passenger counts chosen first

        var colorMap;
        var projection;
        var path;
        var svgMap;

        //Load in GeoJSON data
        d3.json("taxizones.json", function(json) {
    			//Note: You need to lower the translate and make scale higher to make it a bigger map
          projection = d3.geoMercator()
                             //.translate([wMap/0.01059, hMap/0.01752])
                             //.scale([43600]);
                             .fitSize([wMap, hMap], json);

    			//Define path generator
    			 path = d3.geoPath()
    						       .projection(projection);

          //Define quantize scale to sort data values into buckets of color
           colorMap = d3.scaleQuantize()
                        .range(["#C8E6C9","#A5D6A7","#81C784","#66BB6A", "#4CAF50", "#43A047", "#388E3C", "#2E7D32", "#1B5E20", "#123f15", "#0a260c"]);


    			//Create SVG element
    			 svgMap = d3.select("#geoMap")
          						.append("svg")
          						.attr("width", wMap)
          						.attr("height", hMap);

          //Load in taxi zonedata
          d3.csv("zones_passengers_all17.csv", function(data){

            datasetWithAllPassengers = data;
            jsonData = json;
            var passengerValue = 0;
            var subDataset = getSubDataset(datasetWithAllPassengers, passengerIndex);

            //Set input domain for color scale
            colorMap.domain([d3.min([0]),
                             d3.max(subDataset, function(d) {return d.num; })
                            ]);

            //Merge the taxi data and GeoJSON. Loop through once for each taxi data value
            for (var i = 0; i < subDataset.length; i++) {
              //Lets grap the id of the zone
              var zoneID = subDataset[i].zone;
              passengerValue = subDataset[i].num;

              //Find the corresponding state inside the GeoJSON
              for (var j = 0; j < jsonData.features.length; j++) {
                var jsonZone = jsonData.features[j].properties.locationid;
                if (zoneID == jsonZone) {
                  //Copy the data value into the JSON
                  jsonData.features[j].properties.valueP = passengerValue;
                  //Stop looking through the JSON
                  break;
                }
              }
            }

            //Bind data and create one path per GeoJSON feature
    				svgMap.selectAll("path")
    				   .data(jsonData.features)
    				   .enter()
    				   .append("path")
    				   .attr("d", path)
               .style("fill", function(d) {
                  var value = d.properties.valueP;
                  if (value) {
                    return colorMap(value);
                  } else {
                    //If value is undefined
                    return "#ccc";}
               })
               .style("fill-opacity","1")
               .attr("stroke-width", 0.1)
               .attr("stroke", "black")
               .on("mouseover", function(d) {  //Create tooltip
                 var xPosition = 350 ;  //Make tooltip be at this position
                 var yPosition = 520 ;
                 d3.select(this).style("fill-opacity","0.7");

                 //Create the tooltip label
                 svgMap.append("text")
                   .attr("id", "tooltip")
                   .attr("x", xPosition)
                   .attr("y", yPosition)
                   .attr("text-anchor", "middle")
                   .attr("font-family", "sans-serif")
                   .attr("font-size", "11px")
                   .attr("fill", "black")
                   .text("Zone: "+ d.properties.zone + " - Number of taxi trips: "  + d.properties.valueP);
               })
               .on("mouseout", function() {
                   d3.select("#tooltip").remove(); //Remove the tooltip
                   d3.selectAll("path").style("fill-opacity","1");
               });
    			   });
           });

           //Function to update the map when clicking the checkbuttons
           var updateChartBar = function() {
               //find out which checkboxes are checked and should be displayed on the map
               passengerIndex = isChecked();

               //get the subdataset
               var subDataset = getSubDataset(datasetWithAllPassengers, passengerIndex, jsonData);

               //now update the map
               colorMap.domain([d3.min([0]),
                                d3.max(subDataset, function(d) {return d.num; })
                                ]);

                //Merge the taxi data and GeoJSON. Loop through once for each taxi data value
                for (var i = 0; i < subDataset.length; i++) {
                  //Lets grap the id of the zone
                  var zoneID = subDataset[i].zone;
                  passengerValue = subDataset[i].num;

                  //Find the corresponding state inside the GeoJSON
                  for (var j = 0; j < jsonData.features.length; j++) {
                    var jsonZone = jsonData.features[j].properties.locationid;
                    if (zoneID == jsonZone) {
                      //Copy the data value into the JSON
                      jsonData.features[j].properties.valueP = passengerValue;
                      //Stop looking through the JSON
                      break;
                    }
                  }
                }

                 //Bind data and create one path per GeoJSON feature
                svgMap.selectAll("path")
                       .data(jsonData.features)
                       .transition()
                       .duration(800)
                       .attr("d", path)
                       .style("fill", function(d) {
                           var value = d.properties.valueP;
                           if (value) {
                             return colorMap(value);
                           } else {
                             //If value is undefined
                             return "#ccc";
                           }
                        });
           }

           /***************************************************************
           *****             Barchart for number of passengers        *****
           ****************************************************************/


           // Next we declare some usefule variables
           var possiblePassengers = [1, 2, 3, 4, 5, 6];
           //var positionsHoursOnly = [];
           var xScaleBarPassengers, yScaleBarPassengers, svgBarPassengers, xAxisBarPassengers, yAxisBarPassengers;


           d3.csv("data/passengerCount_all17.csv", function(data) {
             var datasetPassengers = data;

             // lets create the scales
             xScaleBarPassengers = d3.scaleBand()
               .domain(possiblePassengers)
               .rangeRound([padding * 2, width])  // 'rangeRound' enables rounding | double padding to make room for the numbers
               .paddingInner(0.5);

             yScaleBarPassengers = d3.scaleLinear()
               .domain([0, d3.max(datasetPassengers, function(d) { return d.num; })])
               .range([height - padding, padding * 2]); // double padding on the top to have room for title

             //Create SVG element
             svgBarPassengers = d3.select("#passenger_bar")
                     .append("svg")
                     .attr("width", width)
                     .attr("height", height);

             //Create the bars
             svgBarPassengers.selectAll("rect")
                .data(datasetPassengers)
                .enter()
                .append("rect")
                .attr("x", function(d) {
                   return xScaleBarPassengers(d.passenger_count);  // Setting x values
                })
                .attr("y", function(d) {
                   return yScaleBarPassengers(d.num);
                })
                .attr("width", xScaleBarPassengers.bandwidth())
                .attr("height", function(d) {
                   return height - yScaleBarPassengers(d.num) - padding;
                })
                .attr("fill", function(d) {
                  return "#25b898"
                });

              // Define X axis
              xAxisBarPassengers = d3.axisBottom()
                  .scale(xScaleBarPassengers)
                  .tickValues(possiblePassengers);

              //Define Y axis
              yAxisBarPassengers = d3.axisLeft()
                        .scale(yScaleBarPassengers)
                        .ticks(5);

              //Create X axis
              svgBarPassengers.append("g")
                 .attr("class", "x axis")
                 .attr("transform", "translate(0," + (height - padding) + ")")
                 .call(xAxisBarPassengers);

              //Create Y axis
              svgBarPassengers.append("g")
                .attr("class", "y axis")
                .attr("transform", "translate(" + padding * 2 + ",0)") // double padding to make room for the numbers
                .call(yAxisBarPassengers);

              // Setting y label
              svgBarPassengers.append("text")
                 .attr("transform", "rotate(-90)")
                 .attr("y", 0)
                 .attr("x",0 - (height / 2))
                 .attr("dy", "1em")
                 .style("text-anchor", "middle")
                 .style("font-weight", "bolder")
                 .style("font-size", "10px")
                 .text("# of taxi trips");

             // Setting x label
             svgBarPassengers.append("text")
                .attr("y", height - 15)
                .attr("x", (width / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-weight", "bolder")
                .style("font-size", "10px")
                .text("Amount of passengers");

              // Setting the title
              svgBarPassengers.append("text")
                 .attr("x", width / 2)
                 .attr("y", padding) // we want little bit of padding from the top
                 .attr("text-anchor", "middle")
                 .style("font-size", "19px")
                 .style("font-weight", "bolder")
                 .text("Amount of passengers per taxi ride");




           });



          /***************************************************************
          *****                       PIE CHARTS                     *****
          ****************************************************************/


          var datasetPie1 = [ 0.8749, 0.1251 ];
          var datasetPie2 = [ 0.8813, 0.1187 ];
          var pieW = 300;
          var pieH = 300;
          var datasetPie1 = [ 0.8749, 0.1251 ];
          var datasetPie2 = [ 0.8813, 0.1187 ];
          var outerRadius = pieW / 2;
          var innerRadius = pieW / 3;


          //  ------  FIRST PIE
          var arc1 = d3.arc()
                .innerRadius(innerRadius)
                .outerRadius(outerRadius);

          var pie1 = d3.pie();

          //Easy colors accessible via a 10-step ordinal scale
          var color = d3.scaleOrdinal(d3.schemeCategory10);
          //Create SVG element
          var svgPie1 = d3.select("#pie1")
                .append("svg")
                .attr("width", pieW)
                .attr("height", pieH);

          //Set up groups
          var arcs1 = svgPie1.selectAll("g.arc")
                  .data(pie1(datasetPie1))
                  .enter()
                  .append("g")
                  .attr("class", "arc")
                  .attr("transform", "translate(" + outerRadius + "," + outerRadius + ")");

          //Draw arc paths
          arcs1.append("path")
              .attr("fill", function(d, i) {
                return color(i);
              })
              .attr("d", arc1);

          //Labels
          arcs1.append("text")
              .attr("transform", function(d) {
                return "translate(" + arc1.centroid(d) + ")";
              })
              .attr("text-anchor", "middle")
              .text(function(d) {
                var value = Math.floor(d.value * 1000)/ 10;
                var description = '';
                if (value < 50) {
                  description = "Tips: "
                } else {
                  description = "Fare: "
                }
                return description + "" + value + "%";
              });


          //  ------  SECOND PIE
          var arc2 = d3.arc()
                .innerRadius(innerRadius)
                .outerRadius(outerRadius);

          var pie2 = d3.pie();

          //Create SVG element
          var svgPie2 = d3.select("#pie2")
                .append("svg")
                .attr("width", pieW)
                .attr("height", pieH);

          //Set up groups
          var arcs2 = svgPie2.selectAll("g.arc")
                  .data(pie2(datasetPie2))
                  .enter()
                  .append("g")
                  .attr("class", "arc")
                  .attr("transform", "translate(" + outerRadius + "," + outerRadius + ")");

          //Draw arc paths
          arcs2.append("path")
              .attr("fill", function(d, i) {
                return color(i);
              })
              .attr("d", arc2);

          //Labels
          arcs2.append("text")
              .attr("transform", function(d) {
                return "translate(" + arc2.centroid(d) + ")";
              })
              .attr("text-anchor", "middle")
              .text(function(d) {
                var value = Math.floor(d.value * 1000)/ 10;
                var description = '';
                if (value < 50) {
                  description = "Tips: "
                } else {
                  description = "Fare: "
                }
                return description + "" + value + "%";
              });

          /***************************************************************
          *****               Barcharts with hours only              *****
          ****************************************************************/


          // Next we declare some usefule variables
          var possibleHoursOnly = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
          var positionsHoursOnly = [];
          var xScaleHoursOnlyChart, yScaleHoursOnlyChart, svgHoursOnlyChart, xAxisHoursOnlyChart, yAxisHoursOnlyChart;

          var rowHoursOnlyConverter = function(d) {
            return {
              hours: parseInt(d.hours),
              num: parseInt(d.num),
            };
          }


          d3.csv("data/hours_number_only.csv", rowHoursOnlyConverter, function(data) {

            var dataset = data;

            // lets create the scales
            xScaleHoursOnlyChart = d3.scaleBand()
              .domain(possibleHoursOnly)
              .rangeRound([padding * 2, width])  // 'rangeRound' enables rounding | double padding to make room for the numbers
              .paddingInner(0.5);

            // update positionsHoursOnly array
            for (var i = 0; i < 24; i++) {
              positionsHoursOnly.push(xScaleHoursOnlyChart(i));
            }

            yScaleHoursOnlyChart = d3.scaleLinear()
              .domain([0, d3.max(dataset, function(d) { return d.num; })])
              .range([height - padding, padding * 2]); // double padding on the top to have room for title

            //Create SVG element
            svgHoursOnlyChart = d3.select("#hours_chart2")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

            // Setting chart lines (really long ticks)
            svgHoursOnlyChart.append("g")
               .call(make_y_axis(yScaleHoursOnlyChart, svgHoursOnlyChart)
                      .tickSize(-width, 0, 0)
                      .tickFormat("")
               )
               .attr("transform", "translate(" + padding * 2 + ",0)");

            //Create bars
            svgHoursOnlyChart.selectAll("rect")
               .data(dataset)
               .enter()
               .append("rect")
               .attr("x", function(d, i) {
                  return xScaleHoursOnlyChart(d.hours);  // Setting x values
               })
               .attr("y", function(d) {
                  return yScaleHoursOnlyChart(d.num);
               })
               .attr("class", function(d, i) {
                 return "hour-rect-no-" + i;
               })
               .attr("width", xScaleHoursOnlyChart.bandwidth())
               .attr("height", function(d) {
                  return height - yScaleHoursOnlyChart(d.num) - padding;
               })
               .attr("fill", function(d) {
                 return "#25b898"
               });

             // Define X axis
             xAxisHoursOnlyChart = d3.axisBottom()
                 .scale(xScaleHoursOnlyChart)
                 .tickValues(possibleHoursOnly);

             //Define Y axis
             yAxisHoursOnlyChart = d3.axisLeft()
                       .scale(yScaleHoursOnlyChart)
                       .ticks(5);

             //Create X axis
             svgHoursOnlyChart.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + (height - padding) + ")")
                .call(xAxisHoursOnlyChart);

             //Create Y axis
             svgHoursOnlyChart.append("g")
               .attr("class", "y axis")
               .attr("transform", "translate(" + padding * 2 + ",0)") // double padding to make room for the numbers
               .call(yAxisHoursOnlyChart);

             // Setting y label
             svgHoursOnlyChart.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0)
                .attr("x",0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-weight", "bolder")
                .style("font-size", "10px")
                .text("# of taxi trips");

            // Setting x label
            svgHoursOnlyChart.append("text")
               .attr("y", height - 15)
               .attr("x", (width / 2))
               .attr("dy", "1em")
               .style("text-anchor", "middle")
               .style("font-weight", "bolder")
               .style("font-size", "10px")
               .text("Hour");

             // Setting the title
             svgHoursOnlyChart.append("text")
                .attr("x", width / 2)
                .attr("y", padding) // we want little bit of padding from the top
                .attr("text-anchor", "middle")
                .style("font-size", "19px")
                .style("font-weight", "bolder")
                .text("Pickup Hour");

          });



          /***************************************************************
          *****                 Barcharts with hours                 *****
          ****************************************************************/

          // Next we declare some usefule variables
          var possibleHours = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
          var positionsHours = [];
          var xScaleHoursChart, yScaleHoursChart, svgHoursChart, xAxisHoursChart, yAxisHoursChart;
          var brushhour
          var hourDataset;

          var rowHoursConverter = function(d) {
            return {
              hours: parseInt(d.hours),
              num: parseInt(d.num),
            };
          }


          d3.csv("data/hours_number_only.csv", rowHoursConverter, function(data) {

            var dataset = data;
            hourDataset = dataset.slice();

            // lets create the scales
            xScaleHoursChart = d3.scaleBand()
              .domain(possibleHours)
              .rangeRound([padding * 2, width])  // 'rangeRound' enables rounding | double padding to make room for the numbers
              .paddingInner(0.5);

            // update positionsHours array
            for (var i = 0; i < 24; i++) {
              positionsHours.push(xScaleHoursChart(i));
            }

            yScaleHoursChart = d3.scaleLinear()
              .domain([0, d3.max(dataset, function(d) { return d.num; })])
              .range([height - padding, padding * 2]); // double padding on the top to have room for title

            //Create SVG element
            svgHoursChart = d3.select("#hours_chart1")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

            // Setting chart lines (really long ticks)
            svgHoursChart.append("g")
               .call(make_y_axis(yScaleHoursChart, svgHoursChart)
                      .tickSize(-width, 0, 0)
                      .tickFormat("")
               )
               .attr("transform", "translate(" + padding * 2 + ",0)");

            //Create bars
            svgHoursChart.selectAll("rect")
               .data(dataset)
               .enter()
               .append("rect")
               .attr("x", function(d, i) {
                  return xScaleHoursChart(d.hours);  // Setting x values
               })
               .attr("y", function(d) {
                  return yScaleHoursChart(d.num);
               })
               .attr("class", function(d, i) {
                 return "hour-rect-no-" + i;
               })
               .attr("width", xScaleHoursChart.bandwidth())
               .attr("height", function(d) {
                  return height - yScaleHoursChart(d.num) - padding;
               })
               .attr("fill", function(d) {
                 return "#25b898"
               });

             // Define X axis
             xAxisHoursChart = d3.axisBottom()
                 .scale(xScaleHoursChart)
                 .tickValues(possibleHours);

             //Define Y axis
             yAxisHoursChart = d3.axisLeft()
                       .scale(yScaleHoursChart)
                       .ticks(5);

             //Create X axis
             svgHoursChart.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + (height - padding) + ")")
                .call(xAxisHoursChart);

             //Create Y axis
             svgHoursChart.append("g")
               .attr("class", "y axis")
               .attr("transform", "translate(" + padding * 2 + ",0)") // double padding to make room for the numbers
               .call(yAxisHoursChart);

             // Setting y label
             svgHoursChart.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0)
                .attr("x",0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-weight", "bolder")
                .style("font-size", "10px")
                .text("# of taxi trips");

            // Setting x label
            svgHoursChart.append("text")
               .attr("y", height - 15)
               .attr("x", (width / 2))
               .attr("dy", "1em")
               .style("text-anchor", "middle")
               .style("font-weight", "bolder")
               .style("font-size", "10px")
               .text("Hour");

             // Setting the title
             svgHoursChart.append("text")
                .attr("x", width / 2)
                .attr("y", padding) // we want little bit of padding from the top
                .attr("text-anchor", "middle")
                .style("font-size", "19px")
                .style("font-weight", "bolder")
                .text("Pickup Hour (brushable grap)");

            // setting the brush
            brushHour = d3.brushX()
                    .extent([[padding * 2, padding * 2], [width, height - padding]])
                    .on("brush", highlightBrushedHour)
                    .on("end", onBrushHourEnd);

            svgHoursChart.append("g")
                         .attr("class", "brush-hour")
                         .call(brushHour);


        });

        function onHoursPlay() {

          updateBrush(0);


        }

        function updateBrush(i)  {
          var numberOfRectChosenEachTime = 3;

          var leftPosition = xScaleHoursChart(i) + 3; // extra 3 because otherwise the brush will take one extra rect to the left
          var rightPosition = xScaleHoursChart(i + numberOfRectChosenEachTime) + 10; // 10 a random number so the edge of the brush is little bit more to the right
          d3.select(".brush-hour").call(brushHour.move, [leftPosition, rightPosition]);

          var newI = ++i;
          if (newI < 24 - numberOfRectChosenEachTime) {
            setTimeout(function() {
              updateBrush(++i)
            }, 400);
          }
        }

        function onBrushHourEnd () {
          if (!d3.event.selection) {
            // nothing is highlighted
            var leftHour = 0;
            var rightHour = 23;

            for (var i = 0; i < 24; i++) {
              svgHoursChart.selectAll(".hour-rect-no-" + i)
                 .data(hourDataset)
                 .transition()
                 .duration(300)
                 .attr("fill", function(d) {
                   return "#25b898";
                 });
            }

            // update map with selected data
            updateDurationMapWithSelectedData(leftHour, rightHour);
          }

        }


        function highlightBrushedHour() {
             if (d3.event.selection != null) {

               var extent = d3.event.selection;
               var leftHour = 0;
               var rightHour = 23;

               for (var i = 0; i < 24; i++) {
                 if (extent[0] > positionsHours[i]) {
                   leftHour = i;
                 }
               }

               for (var i = 23; i >= 0; i--) {
                 if (extent[1] < positionsHours[i]) {
                   rightHour = i - 1;
                 }
               }

               // if the width of the selection is zero (or so close to zero), than we use all hours
               if (Math.abs(extent[0] - extent[1]) < 3) { // less than 3 pixels
                 leftHour = 0;
                 rightHour = 23;
               }

               for (var i = 0; i < 24; i++) {
                 svgHoursChart.selectAll(".hour-rect-no-" + i)
                    .data(hourDataset)
                    .transition()
                    .duration(300)
                    .attr("fill", function(d) {

                      if (i < leftHour || i > rightHour) {

                        return "#999999";
                      }
                      return "#25b898";
                    });
               }

               // update map with selected data
               updateDurationMapWithSelectedData(leftHour, rightHour);
             }
         }




         /***************************************************************
         *****                Barcharts with duration               *****
         ****************************************************************/


//         function make_y_axis(scale, svg) {
//           return d3.axisLeft()
//                     .scale(scale)
//                     .ticks(5);
//         }

          // Next we declare some usefule variables
          var possibleDuration = Array.from(new Array(120), (x,i) => i);
          possibleDuration.splice(0, 1); // we don't have any trips with duration 0 minutes, so lets remove that as a possibility
          var xScaleDurationChart, yScaleDurationChart, svgDurationChart, xAxisDurationChart, yAxisDurationChart;
          var durationDataset;

          var rowDurationConverter = function(d) {
            return {
              minutes: parseInt(d.minutes),
              hours: parseInt(d.hours),
              num: parseInt(d.num),
            };
          }

          var sortOutDurationBasedOnHour = function(beginHour, endHour) {
            var newData = Array.from(new Array(120), (x,i) => i);
            for (var i = 0; i < newData.length; i++) {
              newData[i] = {'minutes': + i, 'num': 0  }
            }
            newData.splice(0, 1); // we don't have any trips with duration 0 minutes, so lets remove that as a possibility

            for (var i = 0; i < durationDataset.length ; i++) {
              if (durationDataset[i].hours >= beginHour && durationDataset[i].hours <= endHour) {
                var minutes = durationDataset[i].minutes;
                var numbers = durationDataset[i].num;
                newData[minutes - 1].num += numbers;
              }
            }

            return newData;
          }


          d3.csv("data/duration.csv", rowDurationConverter, function(data) {

            var dataset = data.slice();
            durationDataset = dataset.slice();
            dataset = sortOutDurationBasedOnHour(22,23);

            // lets create the scales
            xScaleDurationChart = d3.scaleBand()
              .domain(possibleDuration)
              .rangeRound([padding * 2, width])  // 'rangeRound' enables rounding | double padding to make room for the numbers
              .paddingInner(0.2);

            yScaleDurationChart = d3.scaleLinear()
              .domain([0, d3.max(dataset, function(d) { return d.num; })])
              .range([height - padding, padding * 2]); // double padding on the top to have room for title

            //Create SVG element
            svgDurationChart = d3.select("#duration_chart1")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

//            // Setting chart lines (really long ticks)
//            svgDurationChart.append("g")
//               .call(make_y_axis(yScaleDurationChart, svgDurationChart)
//                      .tickSize(-width, 0, 0)
//                      .tickFormat("")
//               )
//               .attr("transform", "translate(" + padding * 2 + ",0)");

            // finds the average minitue
            var medianTrip = 0;
            var totalTrips = 0;
            for (var i = 0; i < dataset.length; i++) {
              totalTrips += dataset[i].num;
            }
            medianTrip = totalTrips / 2;

            var medianTripMin = 0;
            var totalTripsAgain = 0;
            for (var i = 0; i < dataset.length; i++) {
              var newTotalTrip = totalTripsAgain + dataset[i].num;
              if (totalTripsAgain < medianTrip && medianTrip < newTotalTrip) {
                medianTripMin = dataset[i].minutes;
                break;
              } else {
                totalTripsAgain = newTotalTrip;
              }
            }


            //Create bars
            svgDurationChart.selectAll("rect")
               .data(dataset)
               .enter()
               .append("rect")
               .attr("x", function(d, i) {
                  return xScaleDurationChart(d.minutes);  // Setting x values
               })
               .attr("y", function(d) {
                  return yScaleDurationChart(d.num);
               })
               .attr("width", xScaleDurationChart.bandwidth())
               .attr("height", function(d) {
                  return height - yScaleDurationChart(d.num) - padding;
               })
               .attr("fill", function(d) {
                 if (d.minutes == medianTripMin) {
                   return "#eda900"
                 }
                 return "#25b898"
               });

             // to skip some ticks on x axis we create new array
             var xAxisTicks = possibleDuration.slice();;
             for (var i = 0; i < xAxisTicks.length; i++) {
               if ((i + 1) % 5 == 0) {

               } else if (i != 0) {
                 xAxisTicks[i] = 1; // so we just draw a lot of ticks for "1" on the x axis
               }

             }

             // Define X axis
             xAxisDurationChart = d3.axisBottom()
                 .scale(xScaleDurationChart)
                 .tickValues(xAxisTicks);
                 //.tickValues(xAxisTicks);

             //Define Y axis
             yAxisDurationChart = d3.axisLeft()
                       .scale(yScaleDurationChart)
                       .ticks(5);

             //Create X axis
             svgDurationChart.append("g")
                .attr("class", "x_duration axis_duration")
                .attr("transform", "translate(0," + (height - padding) + ")")
                .call(xAxisDurationChart);

             //Create Y axis
             svgDurationChart.append("g")
               .attr("class", "y_dyration axis_duration")
               .attr("transform", "translate(" + padding * 2 + ",0)") // double padding to make room for the numbers
               .call(yAxisDurationChart);

             // Setting y label
             svgDurationChart.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0)
                .attr("x",0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-weight", "bolder")
                .style("font-size", "10px")
                .text("# of taxi trips");

            // Setting x label
            svgDurationChart.append("text")
               .attr("y", height - 15)
               .attr("x", (width / 2))
               .attr("dy", "1em")
               .style("text-anchor", "middle")
               .style("font-weight", "bolder")
               .style("font-size", "10px")
               .text("Minutes");

             // Setting the title
             svgDurationChart.append("text")
                .attr("x", width / 2)
                .attr("y", padding) // we want little bit of padding from the top
                .attr("text-anchor", "middle")
                .style("font-size", "19px")
                .style("font-weight", "bolder")
                .text("Trip duration");

          });


          var updateDurationMapWithSelectedData = function(leftHour, rightHour) {
            var dataset = sortOutDurationBasedOnHour(leftHour, rightHour);

            yScaleDurationChart.domain([0, d3.max(dataset, function(d) { return d.num; })]);


            // finds the average minitue
            var medianTrip = 0;
            var totalTrips = 0;
            for (var i = 0; i < dataset.length; i++) {
              totalTrips += dataset[i].num;
            }
            medianTrip = totalTrips / 2;

            var medianTripMin = 0;
            var totalTripsAgain = 0;
            for (var i = 0; i < dataset.length; i++) {
              var newTotalTrip = totalTripsAgain + dataset[i].num;
              if (totalTripsAgain < medianTrip && medianTrip < newTotalTrip) {
                medianTripMin = dataset[i].minutes;
                break;
              } else {
                totalTripsAgain = newTotalTrip;
              }
            }


            // updating all bars
            svgDurationChart.selectAll("rect")
               .data(dataset)
               .transition()
               .duration(1000)
               .attr("x", function(d, i) {
                  return xScaleDurationChart(d.minutes);  // Setting x values
               })
               .attr("y", function(d) {
                  return yScaleDurationChart(d.num);
               })
               .attr("width", xScaleDurationChart.bandwidth())
               .attr("height", function(d) {
                  return height - yScaleDurationChart(d.num) - padding;
               })
               .attr("fill", function(d) {
                 if (d.minutes == medianTripMin) {
                   return "#eda900"
                 }
                 return "#25b898"
               });


               //Update Y axis
               svgDurationChart.select(".y_dyration.axis_duration")
                   .transition()
                   .duration(1000)
                   .call(yAxisDurationChart);

          }








        </script>
    </body>
</html>
